---
title: "Stock Prediction"
author: "Diptendra Nath Bagchi (dbagchi2@illinois.edu) / Sahil Wadhwa (sahilw2@illinois.edu)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: 
    theme: cosmo
    toc: yes
  pdf_document: default
urlcolor: BrickRed
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = 'center')
```

```{r, load-packages, include = FALSE}
# load packages
library(rsample)
library(knitr)
library(kableExtra)
library(ggplot2)
library(gridExtra)
library(tidyverse)
library(caret)
library(gridExtra)
library(lubridate)
library(forecast)
library(mclust)
```

***

# Motivation

In the recent times, financial institutions have put in a lot of effort to create investment strategies using machine learning to make financial gains by predicting the stock prices for next day and sometime at an hourly levels as well. We both are interested in finance as a subject and hence we decided to work on this problem of predicting the stock price for top 100 companies registered at New York Stock Exchange. The problem is slightly more complicated that just using  a linear regression as we know the prices are highly correlated from the previous day and hence this data is a classical use-case for time series. 

But, in this project we will try to include models that we have learnt so far in the class to make stock market predictions. The benefit of doing that is two-fold. One, we will be able to learn about the financial markets and their intricacies and second, we will use this to build a project that we intend on working over a long period of time to make it a complete product.

# Data

This is a stock market(NYSE) data set that we have downloaded from Kaggle. The data set contains four files with different information about the companies. This includes open, close high, low prices of the stock in a particular day. This price data set is available at a daily level but the fundamentals data set is only available at an yearly level. The objective is to predict the next day's open and close price for top 100 companies based on the market capitalization.

Data set consists of following files:

- prices.csv: raw, as-is daily prices. Most of data spans from 2010 to the end 2016, for companies new on stock market date range is shorter. There have been approx. 140 stock splits in that time, this set doesn't account for that.

- prices-split-adjusted.csv: same as prices, but there have been added adjustments for splits.

- securities.csv: general description of each company with division on sectors

- fundamentals.csv: metrics extracted from annual SEC 10K fillings (2012-2016), should be enough to derive most of popular fundamental indicators.[^1]

```{r, message = FALSE}
fundamental = read_csv("data/fundamentals.csv")
prc_splt_adjusted = read_csv("data/prices-split-adjusted.csv")
securities = read_csv("data/securities.csv")
```

```{r, Data-Join}
fundamental$year = year(fundamental$`Period Ending`)
prc_splt_adjusted$year = year(prc_splt_adjusted$date)
```

# Feature engineering

```{r, date-feature}
stock = merge(x = prc_splt_adjusted, y = fundamental, 
              by.x = c("year", "symbol"), by.y = c("year", "Ticker Symbol"))
stock = stock %>% 
  mutate(month = month(date), 
         day_of_month = mday(date),
         day_of_week = wday(date),
         quarter = quarter(date)
         )
```


# Type of task: Regression 

We will predict a stock's open and close price based on the fundamentals and other data provided in the kaggle data set. 

In short, we will train two models - one for predicting the open price and one for the close price for the stock.

This will help us in creating investment strategies for next day. 

# top 10 stocks

```{r}
top_stocks = stock %>% 
  group_by(symbol) %>% 
  summarise(market_cap = median(open * `Common Stocks`)) %>% 
  arrange(desc(market_cap)) %>% 
  top_n(n = 10, wt = market_cap)
```

```{r}
stock = stock %>% 
  filter(symbol %in% top_stocks$symbol)
```

# Modeling

```{r}
one_ticker = stock %>% 
  filter(symbol == "AVGO")
one_ticker = one_ticker %>%
  arrange(date) %>% 
  mutate(index = 1:nrow(one_ticker), 
         ma = ma(x = open, order = 8, centre = TRUE))
```

```{r, count-na}
count_na = one_ticker %>% 
  summarise_all(funs(sum(is.na(.))))
```

```{r }
test_perc = round(0.2 * nrow(one_ticker), digits = 0)
one_ticker_trn = one_ticker[1:(nrow(one_ticker) - test_perc - 1), ]
one_ticker_tst = one_ticker[(nrow(one_ticker) - test_perc): nrow(one_ticker), ]
```

```{r, linear-model}
ctrl = trainControl(method = "timeslice", 
                    initialWindow = round(nrow(one_ticker_trn)/2), 
                    horizon = 1, 
                    fixedWindow = TRUE
                    )
mod_lm = train(open ~ year + month + day_of_month + 
                  day_of_week + index + ma,
               data = one_ticker_trn, 
               method = "lm", 
               trControl = ctrl,
               preProcess = "medianImpute",
               na.action = na.pass
               )
```

```{r, random-forest}
ctrl = trainControl(method = "timeslice", 
                    initialWindow = round(nrow(one_ticker_trn)/2), 
                    horizon = 1, 
                    fixedWindow = TRUE
                    )
mod_rf = train(open ~ year + month + day_of_month + 
                  day_of_week + index + ma,
               data = one_ticker_trn, 
               method = "rf", 
               trControl = ctrl,
               preProcess = "medianImpute",
               na.action = na.pass
               )
```

```{r}
ctrl = trainControl(method = "timeslice", 
                    initialWindow = round(nrow(one_ticker_trn)/2), 
                    horizon = 1, 
                    fixedWindow = TRUE
                    )
mod_pls = train(open ~ year + month + day_of_month + 
                  day_of_week + index + ma,
               data = one_ticker_trn, 
               method = "bagEarth", 
               trControl = ctrl,
               preProcess = "medianImpute",
               na.action = na.pass
               )
```

# Modelling for all 10 stocks

```{r, train-test split}
trn_tst_split = function(df) {
  test_perc = round(0.2 * nrow(df), digits = 0)
  one_ticker_trn = df[1:(nrow(df) - test_perc - 1), ]
  one_ticker_tst = df[(nrow(df) - test_perc): nrow(df), ]
  list(one_ticker_trn, one_ticker_tst)
}
```


```{r}
list_of_stocks = split(x = stock, f = stock$symbol)
list_trn_tst = lapply(list_of_stocks, trn_tst_split)
list_trn = lapply(list_trn_tst, function(x) x[[1]])
list_tst = lapply(list_trn_tst, function(x) x[[2]])
```

```{r}

```


```{r}
#a_stock_pred = predict(mod_lm, predict(preProcess(one_ticker_trn, "medianImpute"), one_ticker_tst))

a_stock_pred = predict(mod_pls, one_ticker_tst, na.action = na.pass)
RMSE(pred = a_stock_pred, obs = one_ticker_tst$open)
```

```{r}
dens = densityMclust(data = one_ticker$open)
plot(dens, what = "density", data = one_ticker$open)
```



```{r}
time_slices = createTimeSlices(y = 1: nrow(stock), initialWindow = nrow(stock)/4, horizon = 1, fixedWindow = TRUE)

```



```{r}





lm_mod = lm(formula = open ~ year + month + day + `Pre-Tax Margin` + `Profit Margin`,  
            data = stock_trn, weights = )
```

# Prediction

It is done only for one stock with ticker symbol AAPL - Apple. 

```{r}
predict_vector = predict(object = lm_mod, newdata = stock_tst)

prediction = tibble("prediction" = predict_vector, 
                    "actual" = stock_tst$open)
prediction %>% 
  kable(digits = 2) %>% 
  kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "center") %>% 
  add_header_above(header = c("Predicted open price for Apple" = 2)) %>% 
  scroll_box(height = "500px")
```


```{r}
response %>% 
  kable(digits = 2) %>% 
  kable_styling(bootstrap_options = "striped", full_width = FALSE, 
                position = "center") %>% 
  add_header_above(header = c("This is our response variable" = 3)) %>% 
  scroll_box(height = "500px")
```

